{"version":3,"file":"index.js","sources":["../src/KeepAliveWebSocket.ts"],"sourcesContent":["import {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nexport type KeepAliveWebSocketEvents = {\n  open(): void;\n  message(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n  error(error?: Error): void;\n  disconnect(): void;\n  close(): void;\n  test(a: number, b: number): void;\n};\n\ntype KeepAliveWebSocketEventNames =\n  EventEmitterTypes.EventNames<KeepAliveWebSocketEvents>;\ntype KeepAliveWebSocketEventArguments =\n  EventEmitterTypes.ArgumentMap<KeepAliveWebSocketEvents>;\ntype ExtractSingleTuple<T> = T extends [infer R] ? R : T;\n\nexport type KeepAliveWebSocketOptions = {\n  url: () => Promise<string> | string;\n  minTimeBetweenReconnectsMS?: number;\n  autoconnect?: boolean;\n  WebSocket?: typeof WebSocket;\n};\n\nexport class KeepAliveWebSocket extends EventEmitter<KeepAliveWebSocketEvents> {\n  private url: () => Promise<string> | string;\n  private connected = false;\n  private connecting = false;\n  private reconnecting = false;\n  private closed = false;\n  private websocket: WebSocket | undefined;\n  private connectTime = Date.now();\n  private minTimeBetweenReconnectsMS = 5000;\n  private WebSocket: typeof WebSocket;\n\n  constructor(options: KeepAliveWebSocketOptions) {\n    super();\n    this.url = options.url;\n    if (options.WebSocket) {\n      this.WebSocket = options.WebSocket;\n    } else {\n      this.WebSocket = WebSocket;\n    }\n    if (options.minTimeBetweenReconnectsMS) {\n      this.minTimeBetweenReconnectsMS = options.minTimeBetweenReconnectsMS;\n    }\n    if (options.autoconnect) {\n      this.connect();\n    }\n  }\n\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n    if (!this.connected) {\n      throw new Error(\"WebSocket not ready\");\n    }\n    this.websocket?.send(data);\n    return this;\n  }\n\n  ready() {\n    if (this.connected) {\n      return Promise.resolve();\n    }\n    return new Promise<void>((resolve, reject) => {\n      if (this.connected) {\n        resolve();\n        return;\n      }\n      const removeAllListeners = () => {\n        this.off(\"open\", onOpen);\n        this.off(\"error\", onError);\n        this.off(\"close\", onClose);\n      };\n      const onOpen = () => {\n        removeAllListeners();\n        resolve();\n      };\n      const onError = () => {\n        removeAllListeners();\n        reject();\n      };\n      const onClose = () => {\n        removeAllListeners();\n        reject();\n      };\n      this.on(\"open\", onOpen);\n      this.on(\"error\", onError);\n      this.on(\"close\", onClose);\n    });\n  }\n\n  waitOnce<K extends KeepAliveWebSocketEventNames>(event: K) {\n    return new Promise<ExtractSingleTuple<KeepAliveWebSocketEventArguments[K]>>(\n      (resolve) => {\n        this.once(event, (...args) => {\n          if (args.length === 1) {\n            resolve(args[0]);\n          } else {\n            resolve(args as never);\n          }\n        });\n      }\n    );\n  }\n\n  close(code?: number, reason?: string) {\n    this.connected = false;\n    this.connecting = false;\n    this.closed = true;\n    if (this.websocket) {\n      this.websocket.close(code, reason);\n    } else {\n      this.emit(\"close\");\n    }\n  }\n\n  async connect() {\n    if (this.connected) {\n      return this;\n    }\n    if (this.connecting) {\n      return this;\n    }\n    this.connecting = true;\n    try {\n      this.connectTime = Date.now();\n      const websocket = new this.WebSocket(await this.url());\n\n      const onOpen = () => {\n        websocket.removeEventListener(\"open\", onOpen);\n        this.connected = true;\n        this.emit(\"open\");\n      };\n      websocket.addEventListener(\"open\", onOpen);\n\n      websocket.addEventListener(\"close\", () => {\n        this.websocket = undefined;\n        this.connected = false;\n        if (this.closed) {\n          this.emit(\"close\");\n        } else {\n          this.emit(\"disconnect\");\n          this.reconnect();\n        }\n      });\n      websocket.addEventListener(\"message\", (event) => {\n        this.emit(\"message\", event.data);\n      });\n      websocket.addEventListener(\"error\", () => {\n        this.emit(\"error\");\n      });\n\n      this.websocket = websocket;\n    } catch (error) {\n      this.emit(\"error\", error as Error);\n      this.reconnect();\n    } finally {\n      this.connecting = false;\n    }\n    return this;\n  }\n\n  private reconnect() {\n    if (this.reconnecting) {\n      return this;\n    }\n    this.reconnecting = true;\n    try {\n      const timeSinceLastConnect = Date.now() - this.connectTime;\n      if (timeSinceLastConnect < this.minTimeBetweenReconnectsMS) {\n        setTimeout(() => {\n          this.connect();\n        }, this.minTimeBetweenReconnectsMS - timeSinceLastConnect);\n      } else {\n        this.connect();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return this;\n  }\n}\n"],"names":["KeepAliveWebSocket","EventEmitter","constructor","options","super","this","connected","connecting","reconnecting","closed","connectTime","Date","now","minTimeBetweenReconnectsMS","url","WebSocket","autoconnect","connect","send","data","Error","_a","websocket","ready","Promise","resolve","reject","removeAllListeners","off","onOpen","onError","onClose","on","waitOnce","event","once","args","length","close","code","reason","emit","removeEventListener","addEventListener","undefined","reconnect","error","timeSinceLastConnect","setTimeout"],"mappings":"+FA2BM,MAAOA,UAA2BC,EAWtC,WAAAC,CAAYC,GACVC,QAVMC,KAASC,WAAG,EACZD,KAAUE,YAAG,EACbF,KAAYG,cAAG,EACfH,KAAMI,QAAG,EAETJ,KAAAK,YAAcC,KAAKC,MACnBP,KAA0BQ,2BAAG,IAKnCR,KAAKS,IAAMX,EAAQW,IACfX,EAAQY,UACVV,KAAKU,UAAYZ,EAAQY,UAEzBV,KAAKU,UAAYA,UAEfZ,EAAQU,6BACVR,KAAKQ,2BAA6BV,EAAQU,4BAExCV,EAAQa,aACVX,KAAKY,SAER,CAED,IAAAC,CAAKC,SACH,IAAKd,KAAKC,UACR,MAAM,IAAIc,MAAM,uBAGlB,OADc,QAAdC,EAAAhB,KAAKiB,iBAAS,IAAAD,GAAAA,EAAEH,KAAKC,GACdd,IACR,CAED,KAAAkB,GACE,OAAIlB,KAAKC,UACAkB,QAAQC,UAEV,IAAID,SAAc,CAACC,EAASC,KACjC,GAAIrB,KAAKC,UAEP,YADAmB,IAGF,MAAME,EAAqB,KACzBtB,KAAKuB,IAAI,OAAQC,GACjBxB,KAAKuB,IAAI,QAASE,GAClBzB,KAAKuB,IAAI,QAASG,EAAQ,EAEtBF,EAAS,KACbF,IACAF,GAAS,EAELK,EAAU,KACdH,IACAD,GAAQ,EAEJK,EAAU,KACdJ,IACAD,GAAQ,EAEVrB,KAAK2B,GAAG,OAAQH,GAChBxB,KAAK2B,GAAG,QAASF,GACjBzB,KAAK2B,GAAG,QAASD,EAAQ,GAE5B,CAED,QAAAE,CAAiDC,GAC/C,OAAO,IAAIV,SACRC,IACCpB,KAAK8B,KAAKD,GAAO,IAAIE,KACC,IAAhBA,EAAKC,OACPZ,EAAQW,EAAK,IAEbX,EAAQW,EACT,GACD,GAGP,CAED,KAAAE,CAAMC,EAAeC,GACnBnC,KAAKC,WAAY,EACjBD,KAAKE,YAAa,EAClBF,KAAKI,QAAS,EACVJ,KAAKiB,UACPjB,KAAKiB,UAAUgB,MAAMC,EAAMC,GAE3BnC,KAAKoC,KAAK,QAEb,CAED,aAAMxB,GACJ,GAAIZ,KAAKC,UACP,OAAOD,KAET,GAAIA,KAAKE,WACP,OAAOF,KAETA,KAAKE,YAAa,EAClB,IACEF,KAAKK,YAAcC,KAAKC,MACxB,MAAMU,EAAY,IAAIjB,KAAKU,gBAAgBV,KAAKS,OAE1Ce,EAAS,KACbP,EAAUoB,oBAAoB,OAAQb,GACtCxB,KAAKC,WAAY,EACjBD,KAAKoC,KAAK,OAAO,EAEnBnB,EAAUqB,iBAAiB,OAAQd,GAEnCP,EAAUqB,iBAAiB,SAAS,KAClCtC,KAAKiB,eAAYsB,EACjBvC,KAAKC,WAAY,EACbD,KAAKI,OACPJ,KAAKoC,KAAK,UAEVpC,KAAKoC,KAAK,cACVpC,KAAKwC,YACN,IAEHvB,EAAUqB,iBAAiB,WAAYT,IACrC7B,KAAKoC,KAAK,UAAWP,EAAMf,KAAK,IAElCG,EAAUqB,iBAAiB,SAAS,KAClCtC,KAAKoC,KAAK,QAAQ,IAGpBpC,KAAKiB,UAAYA,CAClB,CAAC,MAAOwB,GACPzC,KAAKoC,KAAK,QAASK,GACnBzC,KAAKwC,WACN,CAAS,QACRxC,KAAKE,YAAa,CACnB,CACD,OAAOF,IACR,CAEO,SAAAwC,GACN,GAAIxC,KAAKG,aACP,OAAOH,KAETA,KAAKG,cAAe,EACpB,IACE,MAAMuC,EAAuBpC,KAAKC,MAAQP,KAAKK,YAC3CqC,EAAuB1C,KAAKQ,2BAC9BmC,YAAW,KACT3C,KAAKY,SAAS,GACbZ,KAAKQ,2BAA6BkC,GAErC1C,KAAKY,SAER,CAAS,QACRZ,KAAKG,cAAe,CACrB,CACD,OAAOH,IACR"}