{"version":3,"file":"index.js","sources":["../src/KeepAliveWebSocket.ts"],"sourcesContent":["import {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nexport type KeepAliveWebSocketEvents = {\n  open(): void;\n  message(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n  error(error?: Error): void;\n  disconnect(): void;\n  close(): void;\n  test(a: number, b: number): void;\n};\n\ntype KeepAliveWebSocketEventNames =\n  EventEmitterTypes.EventNames<KeepAliveWebSocketEvents>;\ntype KeepAliveWebSocketEventArguments =\n  EventEmitterTypes.ArgumentMap<KeepAliveWebSocketEvents>;\ntype ExtractSingleTuple<T> = T extends [infer R] ? R : T;\n\nexport type KeepAliveWebSocketOptions = {\n  url: () => Promise<string> | string;\n  minTimeBetweenReconnectsMS?: number;\n  WebSocket?: typeof WebSocket;\n};\n\nexport class KeepAliveWebSocket extends EventEmitter<KeepAliveWebSocketEvents> {\n  private url: () => Promise<string> | string;\n  private connecting = false;\n  private reconnecting = false;\n  private closed = false;\n  private websocket: WebSocket | undefined;\n  private connectTime = Date.now();\n  private minTimeBetweenReconnectsMS = 5000;\n  private WebSocket: typeof WebSocket;\n\n  constructor(options: KeepAliveWebSocketOptions) {\n    super();\n    this.url = options.url;\n    if (options.WebSocket) {\n      this.WebSocket = options.WebSocket;\n    } else {\n      this.WebSocket = WebSocket;\n    }\n    if (options.minTimeBetweenReconnectsMS) {\n      this.minTimeBetweenReconnectsMS = options.minTimeBetweenReconnectsMS;\n    }\n    this.connect();\n  }\n\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n    if (!this.websocket) {\n      throw new Error(\"WebSocket not ready\");\n    }\n    this.websocket.send(data);\n    return this;\n  }\n\n  ready() {\n    if (this.websocket) {\n      return Promise.resolve();\n    }\n    return new Promise<void>((resolve, reject) => {\n      const removeAllListeners = () => {\n        this.off(\"open\", onOpen);\n        this.off(\"error\", onError);\n        this.off(\"close\", onClose);\n      };\n      const onOpen = () => {\n        removeAllListeners();\n        resolve();\n      };\n      const onError = () => {\n        removeAllListeners();\n        reject();\n      };\n      const onClose = () => {\n        removeAllListeners();\n        reject();\n      };\n      this.on(\"open\", onOpen);\n      this.on(\"error\", onError);\n      this.on(\"close\", onClose);\n    });\n  }\n\n  waitOnce<K extends KeepAliveWebSocketEventNames>(event: K) {\n    return new Promise<ExtractSingleTuple<KeepAliveWebSocketEventArguments[K]>>(\n      (resolve) => {\n        this.once(event, (...args) => {\n          if (args.length === 1) {\n            resolve(args[0]);\n          } else {\n            resolve(args as never);\n          }\n        });\n      }\n    );\n  }\n\n  close(code?: number, reason?: string) {\n    this.closed = true;\n    if (this.websocket) {\n      this.websocket.close(code, reason);\n    } else {\n      this.emit(\"close\");\n    }\n  }\n\n  private async connect() {\n    if (this.connecting) {\n      return this;\n    }\n    this.connecting = true;\n    try {\n      this.connectTime = Date.now();\n      const websocket = new this.WebSocket(await this.url());\n\n      const onOpen = () => {\n        websocket.removeEventListener(\"open\", onOpen);\n        this.emit(\"open\");\n      };\n      websocket.addEventListener(\"open\", onOpen);\n\n      websocket.addEventListener(\"close\", () => {\n        this.websocket = undefined;\n        if (this.closed) {\n          this.emit(\"close\");\n        } else {\n          this.emit(\"disconnect\");\n          this.reconnect();\n        }\n      });\n      websocket.addEventListener(\"message\", (event) => {\n        this.emit(\"message\", event.data);\n      });\n      websocket.addEventListener(\"error\", () => {\n        this.emit(\"error\");\n      });\n\n      this.websocket = websocket;\n    } catch (error) {\n      this.emit(\"error\", error as Error);\n      this.reconnect();\n    } finally {\n      this.connecting = false;\n    }\n    return this;\n  }\n\n  private reconnect() {\n    if (this.reconnecting) {\n      return this;\n    }\n    this.reconnecting = true;\n    try {\n      const timeSinceLastConnect = Date.now() - this.connectTime;\n      if (timeSinceLastConnect < this.minTimeBetweenReconnectsMS) {\n        setTimeout(() => {\n          this.connect();\n        }, this.minTimeBetweenReconnectsMS - timeSinceLastConnect);\n      } else {\n        this.connect();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return this;\n  }\n}\n"],"names":["KeepAliveWebSocket","EventEmitter","constructor","options","super","this","connecting","reconnecting","closed","connectTime","Date","now","minTimeBetweenReconnectsMS","url","WebSocket","connect","send","data","websocket","Error","ready","Promise","resolve","reject","removeAllListeners","off","onOpen","onError","onClose","on","waitOnce","event","once","args","length","close","code","reason","emit","removeEventListener","addEventListener","undefined","reconnect","error","timeSinceLastConnect","setTimeout"],"mappings":"+FA0BM,MAAOA,UAA2BC,EAUtC,WAAAC,CAAYC,GACVC,QATMC,KAAUC,YAAG,EACbD,KAAYE,cAAG,EACfF,KAAMG,QAAG,EAETH,KAAAI,YAAcC,KAAKC,MACnBN,KAA0BO,2BAAG,IAKnCP,KAAKQ,IAAMV,EAAQU,IACfV,EAAQW,UACVT,KAAKS,UAAYX,EAAQW,UAEzBT,KAAKS,UAAYA,UAEfX,EAAQS,6BACVP,KAAKO,2BAA6BT,EAAQS,4BAE5CP,KAAKU,SACN,CAED,IAAAC,CAAKC,GACH,IAAKZ,KAAKa,UACR,MAAM,IAAIC,MAAM,uBAGlB,OADAd,KAAKa,UAAUF,KAAKC,GACbZ,IACR,CAED,KAAAe,GACE,OAAIf,KAAKa,UACAG,QAAQC,UAEV,IAAID,SAAc,CAACC,EAASC,KACjC,MAAMC,EAAqB,KACzBnB,KAAKoB,IAAI,OAAQC,GACjBrB,KAAKoB,IAAI,QAASE,GAClBtB,KAAKoB,IAAI,QAASG,EAAQ,EAEtBF,EAAS,KACbF,IACAF,GAAS,EAELK,EAAU,KACdH,IACAD,GAAQ,EAEJK,EAAU,KACdJ,IACAD,GAAQ,EAEVlB,KAAKwB,GAAG,OAAQH,GAChBrB,KAAKwB,GAAG,QAASF,GACjBtB,KAAKwB,GAAG,QAASD,EAAQ,GAE5B,CAED,QAAAE,CAAiDC,GAC/C,OAAO,IAAIV,SACRC,IACCjB,KAAK2B,KAAKD,GAAO,IAAIE,KACC,IAAhBA,EAAKC,OACPZ,EAAQW,EAAK,IAEbX,EAAQW,EACT,GACD,GAGP,CAED,KAAAE,CAAMC,EAAeC,GACnBhC,KAAKG,QAAS,EACVH,KAAKa,UACPb,KAAKa,UAAUiB,MAAMC,EAAMC,GAE3BhC,KAAKiC,KAAK,QAEb,CAEO,aAAMvB,GACZ,GAAIV,KAAKC,WACP,OAAOD,KAETA,KAAKC,YAAa,EAClB,IACED,KAAKI,YAAcC,KAAKC,MACxB,MAAMO,EAAY,IAAIb,KAAKS,gBAAgBT,KAAKQ,OAE1Ca,EAAS,KACbR,EAAUqB,oBAAoB,OAAQb,GACtCrB,KAAKiC,KAAK,OAAO,EAEnBpB,EAAUsB,iBAAiB,OAAQd,GAEnCR,EAAUsB,iBAAiB,SAAS,KAClCnC,KAAKa,eAAYuB,EACbpC,KAAKG,OACPH,KAAKiC,KAAK,UAEVjC,KAAKiC,KAAK,cACVjC,KAAKqC,YACN,IAEHxB,EAAUsB,iBAAiB,WAAYT,IACrC1B,KAAKiC,KAAK,UAAWP,EAAMd,KAAK,IAElCC,EAAUsB,iBAAiB,SAAS,KAClCnC,KAAKiC,KAAK,QAAQ,IAGpBjC,KAAKa,UAAYA,CAClB,CAAC,MAAOyB,GACPtC,KAAKiC,KAAK,QAASK,GACnBtC,KAAKqC,WACN,CAAS,QACRrC,KAAKC,YAAa,CACnB,CACD,OAAOD,IACR,CAEO,SAAAqC,GACN,GAAIrC,KAAKE,aACP,OAAOF,KAETA,KAAKE,cAAe,EACpB,IACE,MAAMqC,EAAuBlC,KAAKC,MAAQN,KAAKI,YAC3CmC,EAAuBvC,KAAKO,2BAC9BiC,YAAW,KACTxC,KAAKU,SAAS,GACbV,KAAKO,2BAA6BgC,GAErCvC,KAAKU,SAER,CAAS,QACRV,KAAKE,cAAe,CACrB,CACD,OAAOF,IACR"}