{"version":3,"file":"index.js","sources":["../src/KeepAliveWebSocket.ts"],"sourcesContent":["import {\n\tEventEmitter,\n\ttype EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nexport type KeepAliveWebSocketEvents = {\n\topen(): void;\n\tmessage(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n\terror(error?: Error): void;\n\tdisconnect(): void;\n\tclose(): void;\n};\n\ntype KeepAliveWebSocketEventNames =\n\tEventEmitterTypes.EventNames<KeepAliveWebSocketEvents>;\ntype KeepAliveWebSocketEventArguments =\n\tEventEmitterTypes.ArgumentMap<KeepAliveWebSocketEvents>;\ntype EventEmitterReturnType<T> = T extends []\n\t? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n\t\tvoid\n\t: T extends [infer R]\n\t\t? R\n\t\t: T;\n\nexport type KeepAliveWebSocketOptions = {\n\turl: () => Promise<string> | string;\n\tminTimeBetweenReconnectsMS?: number;\n\tautoconnect?: boolean;\n\tWebSocket?: typeof WebSocket;\n};\n\nexport class KeepAliveWebSocket extends EventEmitter<KeepAliveWebSocketEvents> {\n\tprivate url: () => Promise<string> | string;\n\tprivate connected = false;\n\tprivate connecting = false;\n\tprivate reconnecting = false;\n\tprivate closed = false;\n\tprivate websocket: WebSocket | undefined;\n\tprivate connectTime = Date.now();\n\tprivate minTimeBetweenReconnectsMS = 0;\n\tprivate WebSocket: typeof WebSocket;\n\n\tconstructor(options: KeepAliveWebSocketOptions) {\n\t\tsuper();\n\t\tthis.url = options.url;\n\t\tif (options.WebSocket) {\n\t\t\tthis.WebSocket = options.WebSocket;\n\t\t} else {\n\t\t\tthis.WebSocket = WebSocket;\n\t\t}\n\t\tif (options.minTimeBetweenReconnectsMS) {\n\t\t\tthis.minTimeBetweenReconnectsMS = options.minTimeBetweenReconnectsMS;\n\t\t}\n\t\tif (options.autoconnect) {\n\t\t\tthis.connect();\n\t\t}\n\t}\n\n\tsend(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n\t\tif (!this.connected || !this.websocket) {\n\t\t\tthrow new Error(\"WebSocket not ready\");\n\t\t}\n\t\tthis.websocket.send(data);\n\t\treturn this;\n\t}\n\n\tready() {\n\t\tif (this.connected) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\treturn this.waitOnce(\"open\");\n\t}\n\n\twaitOnce<K extends KeepAliveWebSocketEventNames>(event: K) {\n\t\treturn new Promise<\n\t\t\tEventEmitterReturnType<KeepAliveWebSocketEventArguments[K]>\n\t\t>((resolve) => {\n\t\t\tthis.once(event, (...args) => {\n\t\t\t\tswitch (args.length) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tresolve(undefined as never);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresolve(args[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tresolve(args as never);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tclose(code?: number, reason?: string) {\n\t\tthis.connected = false;\n\t\tthis.connecting = false;\n\t\tthis.closed = true;\n\t\tif (this.websocket) {\n\t\t\tthis.websocket.close(code, reason);\n\t\t} else {\n\t\t\tthis.emit(\"close\");\n\t\t}\n\t}\n\n\tasync connect() {\n\t\tif (this.connected) {\n\t\t\treturn this;\n\t\t}\n\t\tif (this.connecting) {\n\t\t\treturn this;\n\t\t}\n\t\tthis.connecting = true;\n\t\ttry {\n\t\t\tthis.connectTime = Date.now();\n\t\t\tconst websocket = new this.WebSocket(await this.url());\n\n\t\t\tconst onOpen = () => {\n\t\t\t\twebsocket.removeEventListener(\"open\", onOpen);\n\t\t\t\tthis.connected = true;\n\t\t\t\tthis.emit(\"open\");\n\t\t\t};\n\t\t\twebsocket.addEventListener(\"open\", onOpen);\n\n\t\t\twebsocket.addEventListener(\"close\", () => {\n\t\t\t\tthis.websocket = undefined;\n\t\t\t\tthis.connected = false;\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tthis.emit(\"close\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.emit(\"disconnect\");\n\t\t\t\t\tthis.reconnect();\n\t\t\t\t}\n\t\t\t});\n\t\t\twebsocket.addEventListener(\"message\", (event) => {\n\t\t\t\tthis.emit(\"message\", event.data);\n\t\t\t});\n\t\t\twebsocket.addEventListener(\"error\", () => {\n\t\t\t\tthis.emit(\"error\");\n\t\t\t});\n\n\t\t\tthis.websocket = websocket;\n\t\t} catch (error) {\n\t\t\tthis.emit(\"error\", error as Error);\n\t\t\tawait this.reconnect();\n\t\t} finally {\n\t\t\tthis.connecting = false;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate async reconnect() {\n\t\tif (this.reconnecting) {\n\t\t\treturn this;\n\t\t}\n\t\tthis.reconnecting = true;\n\t\ttry {\n\t\t\tconst timeSinceLastConnect = Date.now() - this.connectTime;\n\t\t\tif (timeSinceLastConnect < this.minTimeBetweenReconnectsMS) {\n\t\t\t\tawait waitMS(this.minTimeBetweenReconnectsMS - timeSinceLastConnect);\n\t\t\t}\n\t\t\tawait this.connect();\n\t\t} finally {\n\t\t\tthis.reconnecting = false;\n\t\t}\n\t\treturn this;\n\t}\n}\n\nfunction waitMS(ms: number) {\n\treturn new Promise<void>((resolve) => \n\t\tsetTimeout(resolve, ms)\n\t);\n}"],"names":["KeepAliveWebSocket","EventEmitter","constructor","options","super","this","connected","connecting","reconnecting","closed","connectTime","Date","now","minTimeBetweenReconnectsMS","url","WebSocket","autoconnect","connect","send","data","websocket","Error","ready","Promise","resolve","waitOnce","event","once","args","length","undefined","close","code","reason","emit","onOpen","removeEventListener","addEventListener","reconnect","error","timeSinceLastConnect","ms","setTimeout"],"mappings":"+FA+BM,MAAOA,UAA2BC,EAWvC,WAAAC,CAAYC,GACXC,QAVOC,KAASC,WAAG,EACZD,KAAUE,YAAG,EACbF,KAAYG,cAAG,EACfH,KAAMI,QAAG,EAETJ,KAAAK,YAAcC,KAAKC,MACnBP,KAA0BQ,2BAAG,EAKpCR,KAAKS,IAAMX,EAAQW,IACfX,EAAQY,UACXV,KAAKU,UAAYZ,EAAQY,UAEzBV,KAAKU,UAAYA,UAEdZ,EAAQU,6BACXR,KAAKQ,2BAA6BV,EAAQU,4BAEvCV,EAAQa,aACXX,KAAKY,SAEN,CAED,IAAAC,CAAKC,GACJ,IAAKd,KAAKC,YAAcD,KAAKe,UAC5B,MAAM,IAAIC,MAAM,uBAGjB,OADAhB,KAAKe,UAAUF,KAAKC,GACbd,IACP,CAED,KAAAiB,GACC,OAAIjB,KAAKC,UACDiB,QAAQC,UAETnB,KAAKoB,SAAS,OACrB,CAED,QAAAA,CAAiDC,GAChD,OAAO,IAAIH,SAERC,IACFnB,KAAKsB,KAAKD,GAAO,IAAIE,KACpB,OAAQA,EAAKC,QACZ,KAAK,EACJL,OAAQM,GACR,MACD,KAAK,EACJN,EAAQI,EAAK,IACb,MACD,QACCJ,EAAQI,GAET,GACA,GAEH,CAED,KAAAG,CAAMC,EAAeC,GACpB5B,KAAKC,WAAY,EACjBD,KAAKE,YAAa,EAClBF,KAAKI,QAAS,EACVJ,KAAKe,UACRf,KAAKe,UAAUW,MAAMC,EAAMC,GAE3B5B,KAAK6B,KAAK,QAEX,CAED,aAAMjB,GACL,GAAIZ,KAAKC,UACR,OAAOD,KAER,GAAIA,KAAKE,WACR,OAAOF,KAERA,KAAKE,YAAa,EAClB,IACCF,KAAKK,YAAcC,KAAKC,MACxB,MAAMQ,EAAY,IAAIf,KAAKU,gBAAgBV,KAAKS,OAE1CqB,EAAS,KACdf,EAAUgB,oBAAoB,OAAQD,GACtC9B,KAAKC,WAAY,EACjBD,KAAK6B,KAAK,OAAO,EAElBd,EAAUiB,iBAAiB,OAAQF,GAEnCf,EAAUiB,iBAAiB,SAAS,KACnChC,KAAKe,eAAYU,EACjBzB,KAAKC,WAAY,EACbD,KAAKI,OACRJ,KAAK6B,KAAK,UAEV7B,KAAK6B,KAAK,cACV7B,KAAKiC,YACL,IAEFlB,EAAUiB,iBAAiB,WAAYX,IACtCrB,KAAK6B,KAAK,UAAWR,EAAMP,KAAK,IAEjCC,EAAUiB,iBAAiB,SAAS,KACnChC,KAAK6B,KAAK,QAAQ,IAGnB7B,KAAKe,UAAYA,CACjB,CAAC,MAAOmB,GACRlC,KAAK6B,KAAK,QAASK,SACblC,KAAKiC,WACX,CAAS,QACTjC,KAAKE,YAAa,CAClB,CACD,OAAOF,IACP,CAEO,eAAMiC,GACb,GAAIjC,KAAKG,aACR,OAAOH,KAERA,KAAKG,cAAe,EACpB,IACC,MAAMgC,EAAuB7B,KAAKC,MAAQP,KAAKK,YAC3C8B,EAAuBnC,KAAKQ,kCAWnB4B,EAVCpC,KAAKQ,2BAA6B2B,EAW3C,IAAIjB,SAAeC,GACzBkB,WAAWlB,EAASiB,YAVbpC,KAAKY,SACX,CAAS,QACTZ,KAAKG,cAAe,CACpB,CAKH,IAAgBiC,EAJd,OAAOpC,IACP"}