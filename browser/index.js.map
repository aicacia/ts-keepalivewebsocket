{"version":3,"file":"index.js","sources":["../src/KeepAliveWebSocket.ts"],"sourcesContent":["import {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nexport type KeepAliveWebSocketEvents = {\n  open(): void;\n  message(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n  error(error?: Error): void;\n  disconnect(): void;\n  close(): void;\n  test(a: number, b: number): void;\n};\n\ntype KeepAliveWebSocketEventNames =\n  EventEmitterTypes.EventNames<KeepAliveWebSocketEvents>;\ntype KeepAliveWebSocketEventArguments =\n  EventEmitterTypes.ArgumentMap<KeepAliveWebSocketEvents>;\ntype ExtractSingleTuple<T> = T extends [infer R] ? R : T;\n\nexport type KeepAliveWebSocketOptions = {\n  url: () => Promise<string> | string;\n  minTimeBetweenReconnectsMS?: number;\n  autoconnect?: boolean;\n  WebSocket?: typeof WebSocket;\n};\n\nexport class KeepAliveWebSocket extends EventEmitter<KeepAliveWebSocketEvents> {\n  private url: () => Promise<string> | string;\n  private connecting = false;\n  private reconnecting = false;\n  private closed = false;\n  private websocket: WebSocket | undefined;\n  private connectTime = Date.now();\n  private minTimeBetweenReconnectsMS = 5000;\n  private WebSocket: typeof WebSocket;\n\n  constructor(options: KeepAliveWebSocketOptions) {\n    super();\n    this.url = options.url;\n    if (options.WebSocket) {\n      this.WebSocket = options.WebSocket;\n    } else {\n      this.WebSocket = WebSocket;\n    }\n    if (options.minTimeBetweenReconnectsMS) {\n      this.minTimeBetweenReconnectsMS = options.minTimeBetweenReconnectsMS;\n    }\n    if (options.autoconnect) {\n      this.connect();\n    }\n  }\n\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n    if (!this.websocket) {\n      throw new Error(\"WebSocket not ready\");\n    }\n    this.websocket.send(data);\n    return this;\n  }\n\n  ready() {\n    if (this.websocket) {\n      return Promise.resolve();\n    }\n    return new Promise<void>((resolve, reject) => {\n      const removeAllListeners = () => {\n        this.off(\"open\", onOpen);\n        this.off(\"error\", onError);\n        this.off(\"close\", onClose);\n      };\n      const onOpen = () => {\n        removeAllListeners();\n        resolve();\n      };\n      const onError = () => {\n        removeAllListeners();\n        reject();\n      };\n      const onClose = () => {\n        removeAllListeners();\n        reject();\n      };\n      this.on(\"open\", onOpen);\n      this.on(\"error\", onError);\n      this.on(\"close\", onClose);\n    });\n  }\n\n  waitOnce<K extends KeepAliveWebSocketEventNames>(event: K) {\n    return new Promise<ExtractSingleTuple<KeepAliveWebSocketEventArguments[K]>>(\n      (resolve) => {\n        this.once(event, (...args) => {\n          if (args.length === 1) {\n            resolve(args[0]);\n          } else {\n            resolve(args as never);\n          }\n        });\n      }\n    );\n  }\n\n  close(code?: number, reason?: string) {\n    this.closed = true;\n    if (this.websocket) {\n      this.websocket.close(code, reason);\n    } else {\n      this.emit(\"close\");\n    }\n  }\n\n  async connect() {\n    if (this.connecting) {\n      return this;\n    }\n    this.connecting = true;\n    try {\n      this.connectTime = Date.now();\n      const websocket = new this.WebSocket(await this.url());\n\n      const onOpen = () => {\n        websocket.removeEventListener(\"open\", onOpen);\n        this.emit(\"open\");\n      };\n      websocket.addEventListener(\"open\", onOpen);\n\n      websocket.addEventListener(\"close\", () => {\n        this.websocket = undefined;\n        if (this.closed) {\n          this.emit(\"close\");\n        } else {\n          this.emit(\"disconnect\");\n          this.reconnect();\n        }\n      });\n      websocket.addEventListener(\"message\", (event) => {\n        this.emit(\"message\", event.data);\n      });\n      websocket.addEventListener(\"error\", () => {\n        this.emit(\"error\");\n      });\n\n      this.websocket = websocket;\n    } catch (error) {\n      this.emit(\"error\", error as Error);\n      this.reconnect();\n    } finally {\n      this.connecting = false;\n    }\n    return this;\n  }\n\n  private reconnect() {\n    if (this.reconnecting) {\n      return this;\n    }\n    this.reconnecting = true;\n    try {\n      const timeSinceLastConnect = Date.now() - this.connectTime;\n      if (timeSinceLastConnect < this.minTimeBetweenReconnectsMS) {\n        setTimeout(() => {\n          this.connect();\n        }, this.minTimeBetweenReconnectsMS - timeSinceLastConnect);\n      } else {\n        this.connect();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return this;\n  }\n}\n"],"names":["KeepAliveWebSocket","EventEmitter","constructor","options","super","this","connecting","reconnecting","closed","connectTime","Date","now","minTimeBetweenReconnectsMS","url","WebSocket","autoconnect","connect","send","data","websocket","Error","ready","Promise","resolve","reject","removeAllListeners","off","onOpen","onError","onClose","on","waitOnce","event","once","args","length","close","code","reason","emit","removeEventListener","addEventListener","undefined","reconnect","error","timeSinceLastConnect","setTimeout"],"mappings":"+FA2BM,MAAOA,UAA2BC,EAUtC,WAAAC,CAAYC,GACVC,QATMC,KAAUC,YAAG,EACbD,KAAYE,cAAG,EACfF,KAAMG,QAAG,EAETH,KAAAI,YAAcC,KAAKC,MACnBN,KAA0BO,2BAAG,IAKnCP,KAAKQ,IAAMV,EAAQU,IACfV,EAAQW,UACVT,KAAKS,UAAYX,EAAQW,UAEzBT,KAAKS,UAAYA,UAEfX,EAAQS,6BACVP,KAAKO,2BAA6BT,EAAQS,4BAExCT,EAAQY,aACVV,KAAKW,SAER,CAED,IAAAC,CAAKC,GACH,IAAKb,KAAKc,UACR,MAAM,IAAIC,MAAM,uBAGlB,OADAf,KAAKc,UAAUF,KAAKC,GACbb,IACR,CAED,KAAAgB,GACE,OAAIhB,KAAKc,UACAG,QAAQC,UAEV,IAAID,SAAc,CAACC,EAASC,KACjC,MAAMC,EAAqB,KACzBpB,KAAKqB,IAAI,OAAQC,GACjBtB,KAAKqB,IAAI,QAASE,GAClBvB,KAAKqB,IAAI,QAASG,EAAQ,EAEtBF,EAAS,KACbF,IACAF,GAAS,EAELK,EAAU,KACdH,IACAD,GAAQ,EAEJK,EAAU,KACdJ,IACAD,GAAQ,EAEVnB,KAAKyB,GAAG,OAAQH,GAChBtB,KAAKyB,GAAG,QAASF,GACjBvB,KAAKyB,GAAG,QAASD,EAAQ,GAE5B,CAED,QAAAE,CAAiDC,GAC/C,OAAO,IAAIV,SACRC,IACClB,KAAK4B,KAAKD,GAAO,IAAIE,KACC,IAAhBA,EAAKC,OACPZ,EAAQW,EAAK,IAEbX,EAAQW,EACT,GACD,GAGP,CAED,KAAAE,CAAMC,EAAeC,GACnBjC,KAAKG,QAAS,EACVH,KAAKc,UACPd,KAAKc,UAAUiB,MAAMC,EAAMC,GAE3BjC,KAAKkC,KAAK,QAEb,CAED,aAAMvB,GACJ,GAAIX,KAAKC,WACP,OAAOD,KAETA,KAAKC,YAAa,EAClB,IACED,KAAKI,YAAcC,KAAKC,MACxB,MAAMQ,EAAY,IAAId,KAAKS,gBAAgBT,KAAKQ,OAE1Cc,EAAS,KACbR,EAAUqB,oBAAoB,OAAQb,GACtCtB,KAAKkC,KAAK,OAAO,EAEnBpB,EAAUsB,iBAAiB,OAAQd,GAEnCR,EAAUsB,iBAAiB,SAAS,KAClCpC,KAAKc,eAAYuB,EACbrC,KAAKG,OACPH,KAAKkC,KAAK,UAEVlC,KAAKkC,KAAK,cACVlC,KAAKsC,YACN,IAEHxB,EAAUsB,iBAAiB,WAAYT,IACrC3B,KAAKkC,KAAK,UAAWP,EAAMd,KAAK,IAElCC,EAAUsB,iBAAiB,SAAS,KAClCpC,KAAKkC,KAAK,QAAQ,IAGpBlC,KAAKc,UAAYA,CAClB,CAAC,MAAOyB,GACPvC,KAAKkC,KAAK,QAASK,GACnBvC,KAAKsC,WACN,CAAS,QACRtC,KAAKC,YAAa,CACnB,CACD,OAAOD,IACR,CAEO,SAAAsC,GACN,GAAItC,KAAKE,aACP,OAAOF,KAETA,KAAKE,cAAe,EACpB,IACE,MAAMsC,EAAuBnC,KAAKC,MAAQN,KAAKI,YAC3CoC,EAAuBxC,KAAKO,2BAC9BkC,YAAW,KACTzC,KAAKW,SAAS,GACbX,KAAKO,2BAA6BiC,GAErCxC,KAAKW,SAER,CAAS,QACRX,KAAKE,cAAe,CACrB,CACD,OAAOF,IACR"}