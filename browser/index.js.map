{"version":3,"file":"index.js","sources":["../src/KeepAliveWebSocket.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\n\nexport type KeepAliveWebSocketEvents = {\n  open(): void;\n  message(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n  error(error?: Error): void;\n  disconnect(): void;\n  close(): void;\n};\n\nexport type KeepAliveWebSocketOptions = {\n  url: () => Promise<string>;\n  minTimeBetweenReconnectsMS?: number;\n  WebSocket?: typeof WebSocket;\n};\n\nexport class KeepAliveWebSocket extends EventEmitter<KeepAliveWebSocketEvents> {\n  private url: () => Promise<string>;\n  private connecting = false;\n  private reconnecting = false;\n  private closed = false;\n  private websocket: WebSocket | undefined;\n  private connectTime = Date.now();\n  private minTimeBetweenReconnectsMS = 5000;\n  private WebSocket: typeof WebSocket;\n\n  constructor(options: KeepAliveWebSocketOptions) {\n    super();\n    this.url = options.url;\n    if (options.WebSocket) {\n      this.WebSocket = options.WebSocket;\n    } else {\n      this.WebSocket = WebSocket;\n    }\n    if (options.minTimeBetweenReconnectsMS) {\n      this.minTimeBetweenReconnectsMS = options.minTimeBetweenReconnectsMS;\n    }\n    this.connect();\n  }\n\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n    if (!this.websocket) {\n      throw new Error(\"WebSocket not ready\");\n    }\n    this.websocket.send(data);\n    return this;\n  }\n\n  ready() {\n    if (this.websocket) {\n      return Promise.resolve();\n    }\n    return new Promise<void>((resolve, reject) => {\n      const removeAllListeners = () => {\n        this.off(\"open\", onOpen);\n        this.off(\"error\", onError);\n        this.off(\"close\", onClose);\n      };\n      const onOpen = () => {\n        removeAllListeners();\n        resolve();\n      };\n      const onError = () => {\n        removeAllListeners();\n        reject();\n      };\n      const onClose = () => {\n        removeAllListeners();\n        reject();\n      };\n      this.on(\"open\", onOpen);\n      this.on(\"error\", onError);\n      this.on(\"close\", onClose);\n    });\n  }\n\n  close(code?: number, reason?: string) {\n    this.closed = true;\n    if (this.websocket) {\n      this.websocket.close(code, reason);\n    } else {\n      this.emit(\"close\");\n    }\n  }\n\n  private async connect() {\n    if (this.connecting) {\n      return this;\n    }\n    this.connecting = true;\n    try {\n      this.connectTime = Date.now();\n      const websocket = new this.WebSocket(await this.url());\n\n      const onOpen = () => {\n        websocket.removeEventListener(\"open\", onOpen);\n        this.emit(\"open\");\n      };\n      websocket.addEventListener(\"open\", onOpen);\n\n      websocket.addEventListener(\"close\", () => {\n        this.websocket = undefined;\n        if (this.closed) {\n          this.emit(\"close\");\n        } else {\n          this.emit(\"disconnect\");\n          this.reconnect();\n        }\n      });\n      websocket.addEventListener(\"message\", (event) => {\n        this.emit(\"message\", event.data);\n      });\n      websocket.addEventListener(\"error\", () => {\n        this.emit(\"error\");\n      });\n\n      this.websocket = websocket;\n    } catch (error) {\n      this.emit(\"error\", error as Error);\n      this.reconnect();\n    } finally {\n      this.connecting = false;\n    }\n    return this;\n  }\n\n  private reconnect() {\n    if (this.reconnecting) {\n      return this;\n    }\n    this.reconnecting = true;\n    try {\n      const timeSinceLastConnect = Date.now() - this.connectTime;\n      if (timeSinceLastConnect < this.minTimeBetweenReconnectsMS) {\n        setTimeout(() => {\n          this.connect();\n        }, this.minTimeBetweenReconnectsMS - timeSinceLastConnect);\n      } else {\n        this.connect();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return this;\n  }\n}\n"],"names":["KeepAliveWebSocket","EventEmitter","constructor","options","super","this","connecting","reconnecting","closed","connectTime","Date","now","minTimeBetweenReconnectsMS","url","WebSocket","connect","send","data","websocket","Error","ready","Promise","resolve","reject","removeAllListeners","off","onOpen","onError","onClose","on","close","code","reason","emit","removeEventListener","addEventListener","undefined","reconnect","event","error","timeSinceLastConnect","setTimeout"],"mappings":"+EAgBM,MAAOA,UAA2BC,EAUtC,WAAAC,CAAYC,GACVC,QATMC,KAAUC,YAAG,EACbD,KAAYE,cAAG,EACfF,KAAMG,QAAG,EAETH,KAAAI,YAAcC,KAAKC,MACnBN,KAA0BO,2BAAG,IAKnCP,KAAKQ,IAAMV,EAAQU,IACfV,EAAQW,UACVT,KAAKS,UAAYX,EAAQW,UAEzBT,KAAKS,UAAYA,UAEfX,EAAQS,6BACVP,KAAKO,2BAA6BT,EAAQS,4BAE5CP,KAAKU,SACN,CAED,IAAAC,CAAKC,GACH,IAAKZ,KAAKa,UACR,MAAM,IAAIC,MAAM,uBAGlB,OADAd,KAAKa,UAAUF,KAAKC,GACbZ,IACR,CAED,KAAAe,GACE,OAAIf,KAAKa,UACAG,QAAQC,UAEV,IAAID,SAAc,CAACC,EAASC,KACjC,MAAMC,EAAqB,KACzBnB,KAAKoB,IAAI,OAAQC,GACjBrB,KAAKoB,IAAI,QAASE,GAClBtB,KAAKoB,IAAI,QAASG,EAAQ,EAEtBF,EAAS,KACbF,IACAF,GAAS,EAELK,EAAU,KACdH,IACAD,GAAQ,EAEJK,EAAU,KACdJ,IACAD,GAAQ,EAEVlB,KAAKwB,GAAG,OAAQH,GAChBrB,KAAKwB,GAAG,QAASF,GACjBtB,KAAKwB,GAAG,QAASD,EAAQ,GAE5B,CAED,KAAAE,CAAMC,EAAeC,GACnB3B,KAAKG,QAAS,EACVH,KAAKa,UACPb,KAAKa,UAAUY,MAAMC,EAAMC,GAE3B3B,KAAK4B,KAAK,QAEb,CAEO,aAAMlB,GACZ,GAAIV,KAAKC,WACP,OAAOD,KAETA,KAAKC,YAAa,EAClB,IACED,KAAKI,YAAcC,KAAKC,MACxB,MAAMO,EAAY,IAAIb,KAAKS,gBAAgBT,KAAKQ,OAE1Ca,EAAS,KACbR,EAAUgB,oBAAoB,OAAQR,GACtCrB,KAAK4B,KAAK,OAAO,EAEnBf,EAAUiB,iBAAiB,OAAQT,GAEnCR,EAAUiB,iBAAiB,SAAS,KAClC9B,KAAKa,eAAYkB,EACb/B,KAAKG,OACPH,KAAK4B,KAAK,UAEV5B,KAAK4B,KAAK,cACV5B,KAAKgC,YACN,IAEHnB,EAAUiB,iBAAiB,WAAYG,IACrCjC,KAAK4B,KAAK,UAAWK,EAAMrB,KAAK,IAElCC,EAAUiB,iBAAiB,SAAS,KAClC9B,KAAK4B,KAAK,QAAQ,IAGpB5B,KAAKa,UAAYA,CAClB,CAAC,MAAOqB,GACPlC,KAAK4B,KAAK,QAASM,GACnBlC,KAAKgC,WACN,CAAS,QACRhC,KAAKC,YAAa,CACnB,CACD,OAAOD,IACR,CAEO,SAAAgC,GACN,GAAIhC,KAAKE,aACP,OAAOF,KAETA,KAAKE,cAAe,EACpB,IACE,MAAMiC,EAAuB9B,KAAKC,MAAQN,KAAKI,YAC3C+B,EAAuBnC,KAAKO,2BAC9B6B,YAAW,KACTpC,KAAKU,SAAS,GACbV,KAAKO,2BAA6B4B,GAErCnC,KAAKU,SAER,CAAS,QACRV,KAAKE,cAAe,CACrB,CACD,OAAOF,IACR"}