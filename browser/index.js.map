{"version":3,"file":"index.js","sources":["../src/KeepAliveWebSocket.ts"],"sourcesContent":["import {\n  EventEmitter,\n  type EventEmitter as EventEmitterTypes,\n} from \"eventemitter3\";\n\nexport type KeepAliveWebSocketEvents = {\n  open(): void;\n  message(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n  error(error?: Error): void;\n  disconnect(): void;\n  close(): void;\n  test(a: number, b: number): void;\n};\n\ntype KeepAliveWebSocketEventNames =\n  EventEmitterTypes.EventNames<KeepAliveWebSocketEvents>;\ntype KeepAliveWebSocketEventArguments =\n  EventEmitterTypes.ArgumentMap<KeepAliveWebSocketEvents>;\ntype EventEmitterReturnType<T> = T extends []\n  ? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n    void\n  : T extends [infer R]\n  ? R\n  : T;\n\nexport type KeepAliveWebSocketOptions = {\n  url: () => Promise<string> | string;\n  minTimeBetweenReconnectsMS?: number;\n  autoconnect?: boolean;\n  WebSocket?: typeof WebSocket;\n};\n\nexport class KeepAliveWebSocket extends EventEmitter<KeepAliveWebSocketEvents> {\n  private url: () => Promise<string> | string;\n  private connected = false;\n  private connecting = false;\n  private reconnecting = false;\n  private closed = false;\n  private websocket: WebSocket | undefined;\n  private connectTime = Date.now();\n  private minTimeBetweenReconnectsMS = 0;\n  private WebSocket: typeof WebSocket;\n\n  constructor(options: KeepAliveWebSocketOptions) {\n    super();\n    this.url = options.url;\n    if (options.WebSocket) {\n      this.WebSocket = options.WebSocket;\n    } else {\n      this.WebSocket = WebSocket;\n    }\n    if (options.minTimeBetweenReconnectsMS) {\n      this.minTimeBetweenReconnectsMS = options.minTimeBetweenReconnectsMS;\n    }\n    if (options.autoconnect) {\n      this.connect();\n    }\n  }\n\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n    if (!this.connected) {\n      throw new Error(\"WebSocket not ready\");\n    }\n    this.websocket?.send(data);\n    return this;\n  }\n\n  ready() {\n    if (this.connected) {\n      return Promise.resolve();\n    }\n    return this.waitOnce(\"open\");\n  }\n\n  waitOnce<K extends KeepAliveWebSocketEventNames>(event: K) {\n    return new Promise<\n      EventEmitterReturnType<KeepAliveWebSocketEventArguments[K]>\n    >((resolve) => {\n      this.once(event, (...args) => {\n        switch (args.length) {\n          case 0:\n            resolve(undefined as never);\n            break;\n          case 1:\n            resolve(args[0]);\n            break;\n          default:\n            resolve(args as never);\n            break;\n        }\n      });\n    });\n  }\n\n  close(code?: number, reason?: string) {\n    this.connected = false;\n    this.connecting = false;\n    this.closed = true;\n    if (this.websocket) {\n      this.websocket.close(code, reason);\n    } else {\n      this.emit(\"close\");\n    }\n  }\n\n  async connect() {\n    if (this.connected) {\n      return this;\n    }\n    if (this.connecting) {\n      return this;\n    }\n    this.connecting = true;\n    try {\n      this.connectTime = Date.now();\n      const websocket = new this.WebSocket(await this.url());\n\n      const onOpen = () => {\n        websocket.removeEventListener(\"open\", onOpen);\n        this.connected = true;\n        this.emit(\"open\");\n      };\n      websocket.addEventListener(\"open\", onOpen);\n\n      websocket.addEventListener(\"close\", () => {\n        this.websocket = undefined;\n        this.connected = false;\n        if (this.closed) {\n          this.emit(\"close\");\n        } else {\n          this.emit(\"disconnect\");\n          this.reconnect();\n        }\n      });\n      websocket.addEventListener(\"message\", (event) => {\n        this.emit(\"message\", event.data);\n      });\n      websocket.addEventListener(\"error\", () => {\n        this.emit(\"error\");\n      });\n\n      this.websocket = websocket;\n    } catch (error) {\n      this.emit(\"error\", error as Error);\n    } finally {\n      this.connecting = false;\n    }\n    return this;\n  }\n\n  private reconnect() {\n    if (this.reconnecting) {\n      return this;\n    }\n    this.reconnecting = true;\n    try {\n      const timeSinceLastConnect = Date.now() - this.connectTime;\n      if (timeSinceLastConnect < this.minTimeBetweenReconnectsMS) {\n        setTimeout(() => {\n          this.connect();\n        }, this.minTimeBetweenReconnectsMS - timeSinceLastConnect);\n      } else {\n        this.connect();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return this;\n  }\n}\n"],"names":["KeepAliveWebSocket","EventEmitter","constructor","options","super","this","connected","connecting","reconnecting","closed","connectTime","Date","now","minTimeBetweenReconnectsMS","url","WebSocket","autoconnect","connect","send","data","Error","_a","websocket","ready","Promise","resolve","waitOnce","event","once","args","length","undefined","close","code","reason","emit","onOpen","removeEventListener","addEventListener","reconnect","error","timeSinceLastConnect","setTimeout"],"mappings":"+FAgCM,MAAOA,UAA2BC,EAWtC,WAAAC,CAAYC,GACVC,QAVMC,KAASC,WAAG,EACZD,KAAUE,YAAG,EACbF,KAAYG,cAAG,EACfH,KAAMI,QAAG,EAETJ,KAAAK,YAAcC,KAAKC,MACnBP,KAA0BQ,2BAAG,EAKnCR,KAAKS,IAAMX,EAAQW,IACfX,EAAQY,UACVV,KAAKU,UAAYZ,EAAQY,UAEzBV,KAAKU,UAAYA,UAEfZ,EAAQU,6BACVR,KAAKQ,2BAA6BV,EAAQU,4BAExCV,EAAQa,aACVX,KAAKY,SAER,CAED,IAAAC,CAAKC,SACH,IAAKd,KAAKC,UACR,MAAM,IAAIc,MAAM,uBAGlB,OADc,QAAdC,EAAAhB,KAAKiB,iBAAS,IAAAD,GAAAA,EAAEH,KAAKC,GACdd,IACR,CAED,KAAAkB,GACE,OAAIlB,KAAKC,UACAkB,QAAQC,UAEVpB,KAAKqB,SAAS,OACtB,CAED,QAAAA,CAAiDC,GAC/C,OAAO,IAAIH,SAERC,IACDpB,KAAKuB,KAAKD,GAAO,IAAIE,KACnB,OAAQA,EAAKC,QACX,KAAK,EACHL,OAAQM,GACR,MACF,KAAK,EACHN,EAAQI,EAAK,IACb,MACF,QACEJ,EAAQI,GAEX,GACD,GAEL,CAED,KAAAG,CAAMC,EAAeC,GACnB7B,KAAKC,WAAY,EACjBD,KAAKE,YAAa,EAClBF,KAAKI,QAAS,EACVJ,KAAKiB,UACPjB,KAAKiB,UAAUU,MAAMC,EAAMC,GAE3B7B,KAAK8B,KAAK,QAEb,CAED,aAAMlB,GACJ,GAAIZ,KAAKC,UACP,OAAOD,KAET,GAAIA,KAAKE,WACP,OAAOF,KAETA,KAAKE,YAAa,EAClB,IACEF,KAAKK,YAAcC,KAAKC,MACxB,MAAMU,EAAY,IAAIjB,KAAKU,gBAAgBV,KAAKS,OAE1CsB,EAAS,KACbd,EAAUe,oBAAoB,OAAQD,GACtC/B,KAAKC,WAAY,EACjBD,KAAK8B,KAAK,OAAO,EAEnBb,EAAUgB,iBAAiB,OAAQF,GAEnCd,EAAUgB,iBAAiB,SAAS,KAClCjC,KAAKiB,eAAYS,EACjB1B,KAAKC,WAAY,EACbD,KAAKI,OACPJ,KAAK8B,KAAK,UAEV9B,KAAK8B,KAAK,cACV9B,KAAKkC,YACN,IAEHjB,EAAUgB,iBAAiB,WAAYX,IACrCtB,KAAK8B,KAAK,UAAWR,EAAMR,KAAK,IAElCG,EAAUgB,iBAAiB,SAAS,KAClCjC,KAAK8B,KAAK,QAAQ,IAGpB9B,KAAKiB,UAAYA,CAClB,CAAC,MAAOkB,GACPnC,KAAK8B,KAAK,QAASK,EACpB,CAAS,QACRnC,KAAKE,YAAa,CACnB,CACD,OAAOF,IACR,CAEO,SAAAkC,GACN,GAAIlC,KAAKG,aACP,OAAOH,KAETA,KAAKG,cAAe,EACpB,IACE,MAAMiC,EAAuB9B,KAAKC,MAAQP,KAAKK,YAC3C+B,EAAuBpC,KAAKQ,2BAC9B6B,YAAW,KACTrC,KAAKY,SAAS,GACbZ,KAAKQ,2BAA6B4B,GAErCpC,KAAKY,SAER,CAAS,QACRZ,KAAKG,cAAe,CACrB,CACD,OAAOH,IACR"}